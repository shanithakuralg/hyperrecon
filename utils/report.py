"""
utils/report.py - Enhanced HTML Report Generator
Part of HyperRecon Pro v4.0 - Advanced Modular Bug Bounty Scanner

Enhanced Features:
- Comprehensive data validation and error handling
- Interactive JavaScript features for better UX
- Browser-compatible responsive design
- Export functionality and data filtering
- Real-time search and filtering capabilities
"""

import os
import json
import html
import traceback
from datetime import datetime
from typing import Dict, List, Any, Optional

class ReportGenerator:
    def __init__(self, hyperrecon_instance):
        self.hyperrecon = hyperrecon_instance
        
        # Enhanced HTML template for individual domain reports with JavaScript
        self.html_template = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HyperRecon Pro Report - {domain}</title>
    <meta name="description" content="Comprehensive security analysis report for {domain} generated by HyperRecon Pro">
    <meta name="author" content="HyperRecon Pro v4.0">
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }}
        
        .container {{
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            overflow: hidden;
        }}
        
        .header {{
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }}
        
        .header h1 {{
            font-size: 2.5em;
            margin-bottom: 10px;
        }}
        
        .header p {{
            font-size: 1.2em;
            opacity: 0.9;
        }}
        
        .stats-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 30px;
            background: #f8f9fa;
        }}
        
        .stat-card {{
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            transition: transform 0.3s ease;
        }}
        
        .stat-card:hover {{
            transform: translateY(-5px);
        }}
        
        .stat-number {{
            font-size: 2.5em;
            font-weight: bold;
            color: #3498db;
        }}
        
        .stat-label {{
            font-size: 1.1em;
            color: #666;
            margin-top: 5px;
        }}
        
        .section {{
            padding: 30px;
            border-bottom: 1px solid #eee;
        }}
        
        .section:last-child {{
            border-bottom: none;
        }}
        
        .section h2 {{
            font-size: 1.8em;
            margin-bottom: 20px;
            color: #2c3e50;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }}
        
        .results-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }}
        
        .result-card {{
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #3498db;
        }}
        
        .result-card h3 {{
            color: #2c3e50;
            margin-bottom: 10px;
        }}
        
        .result-list {{
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border-radius: 5px;
            padding: 10px;
        }}
        
        .result-item {{
            padding: 5px 0;
            border-bottom: 1px solid #eee;
            font-family: monospace;
            font-size: 0.9em;
        }}
        
        .result-item:last-child {{
            border-bottom: none;
        }}
        
        .vulnerability {{
            background: #fff5f5;
            border-left-color: #e53e3e;
        }}
        
        .vulnerability .result-item {{
            color: #c53030;
        }}
        
        .social-media {{
            background: #f0fff4;
            border-left-color: #38a169;
        }}
        
        .footer {{
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 20px;
        }}
        
        .timestamp {{
            background: #ecf0f1;
            padding: 15px;
            text-align: center;
            font-style: italic;
            color: #666;
        }}
        
        .search-container {{
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #eee;
        }}
        
        .search-box {{
            width: 100%;
            max-width: 500px;
            padding: 12px 20px;
            border: 2px solid #ddd;
            border-radius: 25px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s ease;
        }}
        
        .search-box:focus {{
            border-color: #3498db;
        }}
        
        .export-buttons {{
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }}
        
        .export-btn {{
            padding: 8px 16px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease;
        }}
        
        .export-btn:hover {{
            background: #2980b9;
        }}
        
        .filter-tags {{
            margin-top: 10px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }}
        
        .filter-tag {{
            padding: 4px 12px;
            background: #ecf0f1;
            border: 1px solid #bdc3c7;
            border-radius: 15px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }}
        
        .filter-tag.active {{
            background: #3498db;
            color: white;
            border-color: #3498db;
        }}
        
        .hidden {{
            display: none !important;
        }}
        
        .highlight {{
            background-color: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }}
        
        .loading {{
            text-align: center;
            padding: 20px;
            color: #666;
        }}
        
        .error-message {{
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #f5c6cb;
        }}
        
        .success-message {{
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #c3e6cb;
        }}
        
        @media (max-width: 768px) {{
            .stats-grid {{
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
                padding: 20px;
            }}
            
            .results-grid {{
                grid-template-columns: 1fr;
            }}
            
            .section {{
                padding: 20px;
            }}
            
            .header {{
                padding: 20px;
            }}
            
            .header h1 {{
                font-size: 2em;
            }}
            
            .search-container {{
                padding: 15px 20px;
            }}
            
            .export-buttons {{
                justify-content: center;
            }}
        }}
        
        @media (max-width: 480px) {{
            .stats-grid {{
                grid-template-columns: 1fr;
            }}
            
            .stat-card {{
                padding: 15px;
            }}
            
            .stat-number {{
                font-size: 2em;
            }}
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ HyperRecon Pro Report</h1>
            <p>Comprehensive Security Analysis for <strong>{domain}</strong></p>
        </div>
        
        <div class="search-container">
            <input type="text" class="search-box" id="searchBox" placeholder="üîç Search results, URLs, vulnerabilities...">
            <div class="export-buttons">
                <button class="export-btn" onclick="exportToJSON()">üìÑ Export JSON</button>
                <button class="export-btn" onclick="exportToCSV()">üìä Export CSV</button>
                <button class="export-btn" onclick="printReport()">üñ®Ô∏è Print Report</button>
                <button class="export-btn" onclick="toggleDarkMode()">üåô Dark Mode</button>
            </div>
            <div class="filter-tags">
                <span class="filter-tag active" data-filter="all">All Results</span>
                <span class="filter-tag" data-filter="subdomains">Subdomains</span>
                <span class="filter-tag" data-filter="vulnerabilities">Vulnerabilities</span>
                <span class="filter-tag" data-filter="directories">Directories</span>
                <span class="filter-tag" data-filter="social-media">Social Media</span>
            </div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-number">{subdomain_count}</div>
                <div class="stat-label">Subdomains</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{url_count}</div>
                <div class="stat-label">URLs Discovered</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{live_host_count}</div>
                <div class="stat-label">Live Hosts</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{vulnerability_count}</div>
                <div class="stat-label">Vulnerabilities</div>
            </div>
        </div>
        
        {sections_html}
        
        <div class="timestamp">
            Generated on {timestamp} by HyperRecon Pro v4.0
        </div>
        
        <div class="footer">
            <p>üîí HyperRecon Pro v4.0 - Advanced Modular Bug Bounty Scanner</p>
            <p>Created by Saurabh Tomar | GitHub: @saurabhtomar</p>
        </div>
    </div>

    <script>
        // Enhanced JavaScript functionality for interactive report
        
        // Global data storage for export functionality
        let reportData = {report_data_json};
        
        // Search functionality
        document.getElementById('searchBox').addEventListener('input', function(e) {{
            const searchTerm = e.target.value.toLowerCase();
            const sections = document.querySelectorAll('.section, .result-card, .result-item');
            
            sections.forEach(section => {{
                const text = section.textContent.toLowerCase();
                if (text.includes(searchTerm) || searchTerm === '') {{
                    section.style.display = '';
                    // Highlight matching text
                    if (searchTerm !== '') {{
                        highlightText(section, searchTerm);
                    }} else {{
                        removeHighlight(section);
                    }}
                }} else {{
                    section.style.display = 'none';
                }}
            }});
        }});
        
        // Filter functionality
        document.querySelectorAll('.filter-tag').forEach(tag => {{
            tag.addEventListener('click', function() {{
                // Remove active class from all tags
                document.querySelectorAll('.filter-tag').forEach(t => t.classList.remove('active'));
                // Add active class to clicked tag
                this.classList.add('active');
                
                const filter = this.getAttribute('data-filter');
                filterResults(filter);
            }});
        }});
        
        function filterResults(filter) {{
            const sections = document.querySelectorAll('.section');
            
            sections.forEach(section => {{
                if (filter === 'all') {{
                    section.style.display = '';
                }} else {{
                    const sectionTitle = section.querySelector('h2').textContent.toLowerCase();
                    if (sectionTitle.includes(filter.replace('-', ' '))) {{
                        section.style.display = '';
                    }} else {{
                        section.style.display = 'none';
                    }}
                }}
            }});
        }}
        
        // Export functionality
        function exportToJSON() {{
            const dataStr = JSON.stringify(reportData, null, 2);
            const dataBlob = new Blob([dataStr], {{type: 'application/json'}});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = '{domain}_hyperrecon_report.json';
            link.click();
            URL.revokeObjectURL(url);
            showMessage('JSON report exported successfully!', 'success');
        }}
        
        function exportToCSV() {{
            let csvContent = 'Type,Data,Details\\n';
            
            // Export subdomains
            if (reportData.subdomains) {{
                reportData.subdomains.forEach(subdomain => {{
                    csvContent += `Subdomain,"${{subdomain}}",""\\n`;
                }});
            }}
            
            // Export URLs
            if (reportData.urls) {{
                reportData.urls.forEach(url => {{
                    csvContent += `URL,"${{url}}",""\\n`;
                }});
            }}
            
            // Export vulnerabilities
            if (reportData.vulnerabilities) {{
                Object.entries(reportData.vulnerabilities).forEach(([type, data]) => {{
                    if (typeof data === 'object') {{
                        Object.entries(data).forEach(([target, vulns]) => {{
                            if (Array.isArray(vulns)) {{
                                vulns.forEach(vuln => {{
                                    csvContent += `Vulnerability,"${{target}}","${{JSON.stringify(vuln)}}"\\n`;
                                }});
                            }}
                        }});
                    }}
                }});
            }}
            
            const dataBlob = new Blob([csvContent], {{type: 'text/csv'}});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = '{domain}_hyperrecon_report.csv';
            link.click();
            URL.revokeObjectURL(url);
            showMessage('CSV report exported successfully!', 'success');
        }}
        
        function printReport() {{
            window.print();
        }}
        
        function toggleDarkMode() {{
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDark);
            
            if (isDark) {{
                document.body.style.background = 'linear-gradient(135deg, #2c3e50 0%, #34495e 100%)';
                document.querySelector('.container').style.background = '#34495e';
                document.querySelector('.container').style.color = '#ecf0f1';
            }} else {{
                document.body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                document.querySelector('.container').style.background = 'white';
                document.querySelector('.container').style.color = '#333';
            }}
        }}
        
        function highlightText(element, searchTerm) {{
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {{
                textNodes.push(node);
            }}
            
            textNodes.forEach(textNode => {{
                const text = textNode.textContent;
                const regex = new RegExp(`(${{searchTerm}})`, 'gi');
                if (regex.test(text)) {{
                    const highlightedText = text.replace(regex, '<span class="highlight">$1</span>');
                    const wrapper = document.createElement('div');
                    wrapper.innerHTML = highlightedText;
                    textNode.parentNode.replaceChild(wrapper, textNode);
                }}
            }});
        }}
        
        function removeHighlight(element) {{
            const highlights = element.querySelectorAll('.highlight');
            highlights.forEach(highlight => {{
                const parent = highlight.parentNode;
                parent.replaceChild(document.createTextNode(highlight.textContent), highlight);
                parent.normalize();
            }});
        }}
        
        function showMessage(message, type) {{
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'success' ? 'success-message' : 'error-message';
            messageDiv.textContent = message;
            
            const container = document.querySelector('.container');
            container.insertBefore(messageDiv, container.firstChild);
            
            setTimeout(() => {{
                messageDiv.remove();
            }}, 3000);
        }}
        
        // Load dark mode preference
        document.addEventListener('DOMContentLoaded', function() {{
            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            if (isDarkMode) {{
                toggleDarkMode();
            }}
        }});
        
        // Add smooth scrolling for better UX
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {{
            anchor.addEventListener('click', function (e) {{
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {{
                    target.scrollIntoView({{
                        behavior: 'smooth',
                        block: 'start'
                    }});
                }}
            }});
        }});
        
        // Performance monitoring
        window.addEventListener('load', function() {{
            const loadTime = performance.now();
            console.log(`Report loaded in ${{loadTime.toFixed(2)}}ms`);
        }});
        
        // Error handling for failed operations
        window.addEventListener('error', function(e) {{
            console.error('Report error:', e.error);
            showMessage('An error occurred. Please check the console for details.', 'error');
        }});
    </script>
</body>
</html>"""
        
        # Master report template for multiple domains
        self.master_template = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HyperRecon Pro Master Report</title>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }}
        
        .container {{
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            overflow: hidden;
        }}
        
        .header {{
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }}
        
        .header h1 {{
            font-size: 3em;
            margin-bottom: 15px;
        }}
        
        .summary-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            padding: 40px;
            background: #f8f9fa;
        }}
        
        .summary-card {{
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }}
        
        .summary-number {{
            font-size: 3em;
            font-weight: bold;
            color: #3498db;
        }}
        
        .domain-section {{
            padding: 30px;
            border-bottom: 2px solid #eee;
        }}
        
        .domain-header {{
            background: linear-gradient(135deg, #16a085 0%, #2ecc71 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }}
        
        .domain-stats {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }}
        
        .domain-stat {{
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }}
        
        .footer {{
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 20px;
        }}
        
        .timestamp {{
            background: #ecf0f1;
            padding: 15px;
            text-align: center;
            font-style: italic;
            color: #666;
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåê HyperRecon Pro Master Report</h1>
            <p>Multi-Domain Security Analysis Summary</p>
            <p>Scanned {domain_count} domains</p>
        </div>
        
        <div class="summary-grid">
            <div class="summary-card">
                <div class="summary-number">{total_subdomains}</div>
                <div class="stat-label">Total Subdomains</div>
            </div>
            <div class="summary-card">
                <div class="summary-number">{total_urls}</div>
                <div class="stat-label">Total URLs</div>
            </div>
            <div class="summary-card">
                <div class="summary-number">{total_vulns}</div>
                <div class="stat-label">Total Vulnerabilities</div>
            </div>
            <div class="summary-card">
                <div class="summary-number">{total_live_hosts}</div>
                <div class="stat-label">Total Live Hosts</div>
            </div>
        </div>
        
        {domains_html}
        
        <div class="timestamp">
            Generated on {timestamp} by HyperRecon Pro v4.0
        </div>
        
        <div class="footer">
            <p>üîí HyperRecon Pro v4.0 - Advanced Modular Bug Bounty Scanner</p>
            <p>Created by Saurabh Tomar | GitHub: @saurabhtomar</p>
        </div>
    </div>
</body>
</html>"""
    
    def generate_html_report(self, results: Dict[str, Any], domain_path: str) -> Optional[str]:
        """
        Generate enhanced HTML report for a single domain with comprehensive error handling
        
        Args:
            results: Dictionary containing scan results
            domain_path: Path to save the report
            
        Returns:
            Path to generated report or None if failed
        """
        if not results:
            self._log_message("No results provided for HTML report generation", "warning")
            return None
        
        if not os.path.exists(domain_path):
            try:
                os.makedirs(domain_path, exist_ok=True)
            except Exception as e:
                self._log_message(f"Failed to create domain path {domain_path}: {e}", "error")
                return None
        
        domain = self._sanitize_string(results.get('domain', 'unknown'))
        self._log_message(f"Generating HTML report for {domain}", "info")
        
        try:
            # Validate and sanitize results data
            validated_results = self._validate_results_data(results)
            
            # Calculate statistics with error handling
            stats = self._calculate_statistics(validated_results)
            
            # Generate sections HTML with error handling
            sections_html = self._generate_sections_html_safe(validated_results)
            
            # Prepare report data for JavaScript (sanitized for JSON)
            report_data_json = self._prepare_report_data_json(validated_results)
            
            # Fill template with comprehensive error handling
            html_content = self._render_template_safe(
                domain=domain,
                subdomain_count=stats['subdomain_count'],
                url_count=stats['url_count'],
                live_host_count=stats['live_host_count'],
                vulnerability_count=stats['vulnerability_count'],
                sections_html=sections_html,
                report_data_json=report_data_json,
                timestamp=datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            )
            
            if not html_content:
                self._log_message("Failed to render HTML template", "error")
                return None
            
            # Save HTML report with error handling
            report_path = os.path.join(domain_path, 'hyperrecon_report.html')
            return self._save_report_safe(html_content, report_path, domain)
            
        except Exception as e:
            self._log_message(f"Failed to generate HTML report for {domain}: {e}", "error")
            self._log_message(f"Traceback: {traceback.format_exc()}", "debug")
            return None
    
    def generate_sections_html(self, results):
        """Generate HTML sections for different scan results"""
        sections = []
        
        # Subdomains section
        if 'subdomains' in results and results['subdomains']:
            section_html = self.create_list_section(
                "üîç Subdomains Discovered", 
                results['subdomains'][:20],  # Show first 20
                f"Found {len(results['subdomains'])} total subdomains"
            )
            sections.append(section_html)
        
        # Live Hosts section
        if 'live_hosts' in results and results['live_hosts']:
            section_html = self.create_list_section(
                "üåê Live Hosts", 
                results['live_hosts'][:15],  # Show first 15
                f"Found {len(results['live_hosts'])} live hosts"
            )
            sections.append(section_html)
        
        # Vulnerabilities section
        if 'vulnerabilities' in results and results['vulnerabilities']:
            section_html = self.create_vulnerability_section(results['vulnerabilities'])
            sections.append(section_html)
        
        # Parameters section
        if 'parameter_urls' in results and results['parameter_urls']:
            section_html = self.create_list_section(
                "üîç Parameter URLs", 
                results['parameter_urls'][:15],  # Show first 15
                f"Found {len(results['parameter_urls'])} parameterized URLs"
            )
            sections.append(section_html)
        
        # Directories section
        if 'directories' in results and results['directories']:
            section_html = self.create_directories_section(results['directories'])
            sections.append(section_html)
        
        # Social Media section
        if 'social_media' in results and results['social_media']:
            section_html = self.create_social_media_section(results['social_media'])
            sections.append(section_html)
        
        return '\n'.join(sections)
    
    def create_list_section(self, title, items, description):
        """Create a simple list section"""
        items_html = '\n'.join([f'<div class="result-item">{item}</div>' for item in items])
        
        return f"""
        <div class="section">
            <h2>{title}</h2>
            <p>{description}</p>
            <div class="result-card">
                <div class="result-list">
                    {items_html}
                </div>
            </div>
        </div>
        """
    
    def create_vulnerability_section(self, vulnerabilities):
        """Create vulnerability section with severity breakdown"""
        vuln_html = ['<div class="section">']
        vuln_html.append('<h2>üõ°Ô∏è Vulnerabilities Found</h2>')
        
        total_vulns = 0
        for vuln_type, vuln_data in vulnerabilities.items():
            if isinstance(vuln_data, dict):
                for target, vulns in vuln_data.items():
                    if isinstance(vulns, list):
                        total_vulns += len(vulns)
                        if vulns:  # Only show if there are vulnerabilities
                            vuln_items = [f'<div class="result-item">{json.dumps(vuln, indent=2)}</div>' for vuln in vulns[:5]]  # Show first 5
                            vuln_html.append(f'''
                            <div class="result-card vulnerability">
                                <h3>{target} ({vuln_type})</h3>
                                <div class="result-list">
                                    {''.join(vuln_items)}
                                </div>
                            </div>
                            ''')
        
        if total_vulns == 0:
            vuln_html.append('<p>‚úÖ No vulnerabilities found</p>')
        
        vuln_html.append('</div>')
        return '\n'.join(vuln_html)
    
    def create_directories_section(self, directories):
        """Create directories section"""
        dir_html = ['<div class="section">']
        dir_html.append('<h2>üìÅ Directories Found</h2>')
        dir_html.append('<div class="results-grid">')
        
        for host, dirs in directories.items():
            if dirs:
                dir_items = [f'<div class="result-item">{directory}</div>' for directory in dirs[:10]]  # Show first 10
                dir_html.append(f'''
                <div class="result-card">
                    <h3>{host}</h3>
                    <div class="result-list">
                        {''.join(dir_items)}
                    </div>
                </div>
                ''')
        
        dir_html.append('</div>')
        dir_html.append('</div>')
        return '\n'.join(dir_html)
    
    def create_social_media_section(self, social_media):
        """Create social media section"""
        social_html = ['<div class="section">']
        social_html.append('<h2>üì± Social Media Intelligence</h2>')
        social_html.append('<div class="results-grid">')
        
        for platform, data in social_media.items():
            if data:
                if isinstance(data, dict) and 'queries' in data:
                    # Search suggestions format
                    queries = data.get('queries', [])
                    query_items = [f'<div class="result-item">{query}</div>' for query in queries[:5]]
                    social_html.append(f'''
                    <div class="result-card social-media">
                        <h3>{platform.title()}</h3>
                        <p>Search Suggestions:</p>
                        <div class="result-list">
                            {''.join(query_items)}
                        </div>
                    </div>
                    ''')
                elif isinstance(data, list):
                    # Direct results format
                    result_items = [f'<div class="result-item">{str(item)}</div>' for item in data[:5]]
                    social_html.append(f'''
                    <div class="result-card social-media">
                        <h3>{platform.title()}</h3>
                        <div class="result-list">
                            {''.join(result_items)}
                        </div>
                    </div>
                    ''')
        
        social_html.append('</div>')
        social_html.append('</div>')
        return '\n'.join(social_html)
    
    def generate_master_report(self, all_results: List[Dict[str, Any]], output_dir: str) -> Optional[str]:
        """
        Generate enhanced master HTML report for multiple domains
        
        Args:
            all_results: List of domain scan results
            output_dir: Directory to save the master report
            
        Returns:
            Path to generated master report or None if failed
        """
        if not all_results:
            self._log_message("No results provided for master report generation", "warning")
            return None
        
        if not os.path.exists(output_dir):
            try:
                os.makedirs(output_dir, exist_ok=True)
            except Exception as e:
                self._log_message(f"Failed to create output directory {output_dir}: {e}", "error")
                return None
        
        self._log_message("Generating master HTML report for all domains", "info")
        
        try:
            # Validate all results data
            validated_results = [self._validate_results_data(result) for result in all_results]
            
            # Calculate total statistics with error handling
            total_stats = self._calculate_master_statistics(validated_results)
            
            # Generate domains HTML with error handling
            domains_html = self._generate_domains_summary_html_safe(validated_results)
            
            # Fill master template with error handling
            html_content = self._render_master_template_safe(
                domain_count=len(validated_results),
                total_subdomains=total_stats['total_subdomains'],
                total_urls=total_stats['total_urls'],
                total_vulns=total_stats['total_vulns'],
                total_live_hosts=total_stats['total_live_hosts'],
                domains_html=domains_html,
                timestamp=datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            )
            
            if not html_content:
                self._log_message("Failed to render master template", "error")
                return None
            
            # Save master report with error handling
            report_path = os.path.join(output_dir, 'hyperrecon_master_report.html')
            return self._save_report_safe(html_content, report_path, "master")
            
        except Exception as e:
            self._log_message(f"Failed to generate master report: {e}", "error")
            self._log_message(f"Traceback: {traceback.format_exc()}", "debug")
            return None
    
    def _calculate_master_statistics(self, all_results: List[Dict[str, Any]]) -> Dict[str, int]:
        """Calculate master statistics with error handling"""
        stats = {
            'total_subdomains': 0,
            'total_urls': 0,
            'total_live_hosts': 0,
            'total_vulns': 0
        }
        
        try:
            for result in all_results:
                stats['total_subdomains'] += len(result.get('subdomains', []))
                stats['total_urls'] += len(result.get('urls', []))
                stats['total_live_hosts'] += len(result.get('live_hosts', []))
                
                # Count vulnerabilities safely
                vulns = result.get('vulnerabilities', {})
                if isinstance(vulns, dict):
                    for vuln_type, vuln_data in vulns.items():
                        if isinstance(vuln_data, dict):
                            for target, target_vulns in vuln_data.items():
                                if isinstance(target_vulns, list):
                                    stats['total_vulns'] += len(target_vulns)
        except Exception as e:
            self._log_message(f"Error calculating master statistics: {e}", "warning")
        
        return stats
    
    def _generate_domains_summary_html_safe(self, all_results: List[Dict[str, Any]]) -> str:
        """Generate domains summary HTML with error handling"""
        try:
            return self.generate_domains_summary_html(all_results)
        except Exception as e:
            self._log_message(f"Error generating domains summary HTML: {e}", "warning")
            return '<div class="domain-section"><h2>‚ö†Ô∏è Error Loading Domain Summaries</h2><p>Some domain summaries could not be displayed.</p></div>'
    
    def _render_master_template_safe(self, **kwargs) -> Optional[str]:
        """Render master HTML template with error handling"""
        try:
            return self.master_template.format(**kwargs)
        except KeyError as e:
            self._log_message(f"Missing master template variable: {e}", "error")
            return None
        except Exception as e:
            self._log_message(f"Master template rendering error: {e}", "error")
            return None
    
    def generate_domains_summary_html(self, all_results):
        """Generate HTML summary for each domain"""
        domains_html = []
        
        for result in all_results:
            domain = result.get('domain', 'unknown')
            subdomain_count = len(result.get('subdomains', []))
            url_count = len(result.get('urls', []))
            live_host_count = len(result.get('live_hosts', []))
            
            # Count vulnerabilities for this domain
            vuln_count = 0
            if 'vulnerabilities' in result:
                vulns = result['vulnerabilities']
                if isinstance(vulns, dict):
                    for vuln_type, vuln_data in vulns.items():
                        if isinstance(vuln_data, dict):
                            vuln_count += sum(len(v) for v in vuln_data.values() if isinstance(v, list))
            
            domain_html = f'''
            <div class="domain-section">
                <div class="domain-header">
                    <h2>üéØ {domain}</h2>
                    <p>Domain Analysis Summary</p>
                </div>
                
                <div class="domain-stats">
                    <div class="domain-stat">
                        <strong>{subdomain_count}</strong><br>Subdomains
                    </div>
                    <div class="domain-stat">
                        <strong>{url_count}</strong><br>URLs
                    </div>
                    <div class="domain-stat">
                        <strong>{live_host_count}</strong><br>Live Hosts
                    </div>
                    <div class="domain-stat">
                        <strong>{vuln_count}</strong><br>Vulnerabilities
                    </div>
                </div>
            </div>
            '''
            
            domains_html.append(domain_html)
        
        return '\n'.join(domains_html)
    
    def _log_message(self, message: str, level: str = "info") -> None:
        """Centralized logging with fallback to print"""
        try:
            if hasattr(self.hyperrecon, 'console') and self.hyperrecon.console:
                if level == "error":
                    self.hyperrecon.console.print(f"‚ùå [red]{message}[/red]")
                elif level == "warning":
                    self.hyperrecon.console.print(f"‚ö†Ô∏è [yellow]{message}[/yellow]")
                elif level == "success":
                    self.hyperrecon.console.print(f"‚úÖ [green]{message}[/green]")
                else:
                    self.hyperrecon.console.print(f"üìä [cyan]{message}[/cyan]")
            else:
                print(f"[{level.upper()}] {message}")
        except Exception:
            print(f"[{level.upper()}] {message}")
    
    def _sanitize_string(self, text: str) -> str:
        """Sanitize string for HTML output"""
        if text is None:
            return 'unknown'
        if not isinstance(text, str):
            text = str(text)
        text = text.strip()
        if not text:
            return 'unknown'
        return html.escape(text)
    
    def _validate_results_data(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Validate and clean results data"""
        validated = {}
        
        # Ensure basic structure
        validated['domain'] = self._sanitize_string(results.get('domain', 'unknown'))
        validated['subdomains'] = self._validate_list(results.get('subdomains', []))
        validated['urls'] = self._validate_list(results.get('urls', []))
        validated['live_hosts'] = self._validate_list(results.get('live_hosts', []))
        validated['parameter_urls'] = self._validate_list(results.get('parameter_urls', []))
        
        # Validate complex structures
        validated['vulnerabilities'] = self._validate_vulnerabilities(results.get('vulnerabilities', {}))
        validated['directories'] = self._validate_directories(results.get('directories', {}))
        validated['social_media'] = self._validate_social_media(results.get('social_media', {}))
        validated['technologies'] = self._validate_dict(results.get('technologies', {}))
        validated['js_files'] = self._validate_list(results.get('js_files', []))
        validated['sensitive_data'] = self._validate_dict(results.get('sensitive_data', {}))
        
        return validated
    
    def _validate_list(self, data: Any) -> List[str]:
        """Validate and clean list data"""
        if not isinstance(data, list):
            return []
        return [self._sanitize_string(item) for item in data if item]
    
    def _validate_dict(self, data: Any) -> Dict[str, Any]:
        """Validate and clean dictionary data"""
        if not isinstance(data, dict):
            return {}
        validated = {}
        for key, value in data.items():
            clean_key = self._sanitize_string(key)
            if isinstance(value, list):
                validated[clean_key] = self._validate_list(value)
            elif isinstance(value, dict):
                validated[clean_key] = self._validate_dict(value)
            else:
                validated[clean_key] = self._sanitize_string(str(value))
        return validated
    
    def _validate_vulnerabilities(self, data: Any) -> Dict[str, Any]:
        """Validate vulnerability data structure"""
        if not isinstance(data, dict):
            return {}
        
        validated = {}
        for vuln_type, vuln_data in data.items():
            clean_type = self._sanitize_string(vuln_type)
            if isinstance(vuln_data, dict):
                validated[clean_type] = {}
                for target, vulns in vuln_data.items():
                    clean_target = self._sanitize_string(target)
                    if isinstance(vulns, list):
                        validated[clean_type][clean_target] = [
                            self._validate_dict(vuln) if isinstance(vuln, dict) else self._sanitize_string(str(vuln))
                            for vuln in vulns
                        ]
        return validated
    
    def _validate_directories(self, data: Any) -> Dict[str, List[str]]:
        """Validate directories data structure"""
        if not isinstance(data, dict):
            return {}
        
        validated = {}
        for host, dirs in data.items():
            clean_host = self._sanitize_string(host)
            validated[clean_host] = self._validate_list(dirs)
        return validated
    
    def _validate_social_media(self, data: Any) -> Dict[str, Any]:
        """Validate social media data structure"""
        if not isinstance(data, dict):
            return {}
        
        validated = {}
        for platform, platform_data in data.items():
            clean_platform = self._sanitize_string(platform)
            if isinstance(platform_data, dict):
                validated[clean_platform] = self._validate_dict(platform_data)
            elif isinstance(platform_data, list):
                validated[clean_platform] = self._validate_list(platform_data)
            else:
                validated[clean_platform] = self._sanitize_string(str(platform_data))
        return validated
    
    def _calculate_statistics(self, results: Dict[str, Any]) -> Dict[str, int]:
        """Calculate statistics with error handling"""
        stats = {
            'subdomain_count': 0,
            'url_count': 0,
            'live_host_count': 0,
            'vulnerability_count': 0
        }
        
        try:
            stats['subdomain_count'] = len(results.get('subdomains', []))
            stats['url_count'] = len(results.get('urls', []))
            stats['live_host_count'] = len(results.get('live_hosts', []))
            
            # Count vulnerabilities safely
            vulns = results.get('vulnerabilities', {})
            if isinstance(vulns, dict):
                for vuln_type, vuln_data in vulns.items():
                    if isinstance(vuln_data, dict):
                        for target, target_vulns in vuln_data.items():
                            if isinstance(target_vulns, list):
                                stats['vulnerability_count'] += len(target_vulns)
        except Exception as e:
            self._log_message(f"Error calculating statistics: {e}", "warning")
        
        return stats
    
    def _generate_sections_html_safe(self, results: Dict[str, Any]) -> str:
        """Generate sections HTML with comprehensive error handling"""
        try:
            return self.generate_sections_html(results)
        except Exception as e:
            self._log_message(f"Error generating sections HTML: {e}", "warning")
            return '<div class="section"><h2>‚ö†Ô∏è Error Loading Results</h2><p>Some results could not be displayed due to data formatting issues.</p></div>'
    
    def _prepare_report_data_json(self, results: Dict[str, Any]) -> str:
        """Prepare sanitized JSON data for JavaScript"""
        try:
            # Create a clean copy for JSON serialization
            json_data = {
                'domain': results.get('domain', ''),
                'subdomains': results.get('subdomains', [])[:100],  # Limit for performance
                'urls': results.get('urls', [])[:100],
                'live_hosts': results.get('live_hosts', [])[:50],
                'vulnerabilities': results.get('vulnerabilities', {}),
                'directories': results.get('directories', {}),
                'social_media': results.get('social_media', {}),
                'timestamp': datetime.now().isoformat()
            }
            return json.dumps(json_data, ensure_ascii=False, indent=2)
        except Exception as e:
            self._log_message(f"Error preparing JSON data: {e}", "warning")
            return '{}'
    
    def _render_template_safe(self, **kwargs) -> Optional[str]:
        """Render HTML template with error handling"""
        try:
            return self.html_template.format(**kwargs)
        except KeyError as e:
            self._log_message(f"Missing template variable: {e}", "error")
            return None
        except Exception as e:
            self._log_message(f"Template rendering error: {e}", "error")
            return None
    
    def _save_report_safe(self, content: str, report_path: str, domain: str) -> Optional[str]:
        """Save report with comprehensive error handling"""
        try:
            with open(report_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            # Verify file was created and has content
            if os.path.exists(report_path) and os.path.getsize(report_path) > 0:
                self._log_message(f"HTML report saved: {report_path}", "success")
                return report_path
            else:
                self._log_message(f"Report file appears to be empty or not created", "error")
                return None
                
        except PermissionError:
            self._log_message(f"Permission denied writing to {report_path}", "error")
            return None
        except OSError as e:
            self._log_message(f"OS error writing report: {e}", "error")
            return None
        except Exception as e:
            self._log_message(f"Unexpected error saving report: {e}", "error")
            return None